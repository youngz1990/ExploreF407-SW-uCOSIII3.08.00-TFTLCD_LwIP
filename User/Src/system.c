/*
  ******************************************************************************
  * @file           : system.c
  * @brief          : 不依赖硬件的系统基础功能实现
  ******************************************************************************
  * @attention
  *
  * 
  *
  ******************************************************************************
  */

#include "system.h"

/* -------------------------------局部变量---------------------------- */

/* -------------------------------局部函数---------------------------- */
static int _ipow(int num, int power);

/*
*********************************************************************************************************
*	函    数: _itoa()
*	说    明: 模仿C语言库函数itoa()实现带符号整数转换成字符串
*	形    参:   num       待转换的带符号整数
*               *string   字符串指针，转换后的字符串存在此处
*               radix     进制数，如8,10,16进制
*	返    回: 无
*********************************************************************************************************
*/
void _itoa(int num, char *string, int radix)
{
  char index[] = "0123456789ABCDEF"; //索引表
  unsigned num_abs;                  //存放要转换的整数的绝对值,转换的整数可能是负数
  int i = 0, j = 0, k = 0;           //i用来指示设置字符串相应位，转换之后i其实就是字符串的长度；转换后顺序是逆序的，有正负的情况，k用来指示调整顺序的开始位置;j用来指示调整顺序时的交换。
  char temp;                         //临时变量，交换两个值时用到

  //获取要转换的整数的绝对值
  if (radix == 10 && num < 0) //要转换成十进制数并且是负数
  {
    num_abs = (unsigned)-num; //将num的绝对值赋给unum
    string[i++] = '-';        //在字符串最前面设置为'-'号，并且索引加1
  }
  else
  {
    num_abs = (unsigned)num; //若是num为正，直接赋值给unum
  }

  //转换部分，注意转换后是逆序的
  do
  {
    if (i == DIGIT2STRING_LENGTH_LIMIT - 1) //数字长度超过字符串能表达的长度，目前是字符串长度是能装得下32位数的
    {
      string[i - 2] = '.';
      string[i - 1] = '.';
      break;
    }
    string[i++] = index[num_abs % (unsigned)radix]; //取unum的最后一位，并设置为str对应位，指示索引加1
    num_abs /= radix;                               //unum去掉最后一位

  } while (num_abs); //直至num_abs为0退出循环

  string[i] = '\0';

  //将顺序调整过来
  if (string[0] == '-')
  {
    k = 1; //如果是负数，符号不用调整，从符号后面开始调整
  }

  for (j = k; j <= (i - 1) / 2; j++) //头尾一一对称交换，i其实就是字符串的长度，索引最大值比长度少1
  {
    temp = string[j];                  //头部赋值给临时变量
    string[j] = string[i - 1 + k - j]; //尾部赋值给头部
    string[i - 1 + k - j] = temp;      //将临时变量的值(其实就是之前的头部值)赋给尾部
  }
}

/*
*********************************************************************************************************
*	函    数: _uitoa()
*	说    明: 模仿C语言库函数itoa()实现无符号整数转换成字符串
*	形    参:   num       待转换的无符号整数
*               *string   字符串指针，转换后的字符串存在此处
*               radix     进制数，如8,10,16进制
*	返    回: 无
*********************************************************************************************************
*/
void _uitoa(unsigned int num, char *string, int radix)
{
  char index[] = "0123456789ABCDEF"; //索引表
  int i = 0, j = 0, k = 0;           //i用来指示设置字符串相应位，转换之后i其实就是字符串的长度；转换后顺序是逆序的，有正负的情况，k用来指示调整顺序的开始位置;j用来指示调整顺序时的交换。
  char temp;                         //临时变量，交换两个值时用到

  //转换部分，注意转换后是逆序的
  do
  {
    if (i == DIGIT2STRING_LENGTH_LIMIT - 1) //数字长度超过字符串能表达的长度，目前是字符串长度是能装得下32位数的
    {
      string[i - 2] = '.';
      string[i - 1] = '.';
      break;
    }
    string[i++] = index[num % (unsigned)radix]; //取unum的最后一位，并设置为str对应位，指示索引加1
    num /= radix;                               //num去掉最后一位
  } while (num);                                //直至num为0退出循环

  string[i] = '\0'; //在字符串最后添加'\0'字符，c语言字符串以'\0'结束。

  //将顺序调整过来
  for (j = k; j <= (i - 1) / 2; j++) //头尾一一对称交换，i其实就是字符串的长度，索引最大值比长度少1
  {
    temp = string[j];                  //头部赋值给临时变量
    string[j] = string[i - 1 + k - j]; //尾部赋值给头部
    string[i - 1 + k - j] = temp;      //将临时变量的值(其实就是之前的头部值)赋给尾部
  }
}

/*
*********************************************************************************************************
*	函    数: _ftoa()
*	说    明: 实现单精度浮点数转换成字符串
*	形    参:   num       待转换的浮点数
*               *string   字符串指针，转换后的字符串存在此处
*               precision 精度，小数点后的位数
*	返    回: 无
*********************************************************************************************************
*/
void _ftoa(float num, char *string, int precision)
{
  int int_part = 0;
  unsigned int flo_part = 0;
  char string_length = 0;

  /* 完成整数部分的转换 */
  int_part = (int)num;
  _itoa(int_part, string, 10);

  do
  {
    int_part /= 10;
    string_length++;
  }while (int_part);

  string[string_length] = '.';
  string_length++;

  /* 完成小数部分的转换 */
  flo_part = (int)(num * _ipow(10, precision) - ((int)num) * _ipow(10, precision));
  _uitoa(flo_part, &string[string_length], 10);
}

/*
*********************************************************************************************************
*	函    数: _ipow()
*	说    明: 求整数的幂
*	形    参:   num       整数
*             power     power次幂
*	返    回: 求出来的值
*********************************************************************************************************
*/
static int _ipow(int num, int power)
{
  int result = 1;

  while(power)
  {
    result *= num;
    power--;
  }

  return result;
}